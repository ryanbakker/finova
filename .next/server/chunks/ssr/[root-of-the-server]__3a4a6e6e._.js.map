{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 13, "column": 0}, "map": {"version":3,"sources":["file:///Users/ryanbakker/Dev/finova/database/db.ts"],"sourcesContent":["import mongoose from \"mongoose\";\n\nconst MONGODB_URL = process.env.MONGODB_URL;\n\ninterface MongooseConnection {\n  conn: typeof mongoose | null;\n  promise: Promise<typeof mongoose> | null;\n}\n\nlet cached: MongooseConnection = (global as any).mongoose;\n\nif (!cached) {\n  cached = (global as any).mongoose = {\n    conn: null,\n    promise: null,\n  };\n}\n\nexport const connectToDB = async () => {\n  console.log(\"connectToDB called\");\n  console.log(\"MONGODB_URL exists:\", !!MONGODB_URL);\n\n  // Temporary debug log - redact sensitive parts\n  if (MONGODB_URL) {\n    const url = MONGODB_URL;\n    const redactedUrl = url.replace(\n      /(mongodb\\+srv?:\\/\\/)([^:]+):([^@]+)@/,\n      \"$1***:***@\"\n    );\n    console.log(\"MONGODB_URL (redacted):\", redactedUrl);\n\n    // Check if connection string has proper SSL parameters\n    if (\n      url.includes(\"mongodb+srv://\") &&\n      !url.includes(\"ssl=true\") &&\n      !url.includes(\"tls=true\")\n    ) {\n      console.log(\n        \"Warning: MongoDB Atlas connection string detected without explicit SSL parameters\"\n      );\n    }\n  } else {\n    console.log(\"MONGODB_URL is undefined\");\n  }\n\n  if (cached.conn) {\n    console.log(\"Using cached connection\");\n    return cached.conn;\n  }\n\n  if (!MONGODB_URL) throw new Error(\"Missing MONGODB_URL\");\n\n  console.log(\"Creating new database connection...\");\n\n  // Parse the connection string to check if it's MongoDB Atlas\n  const isAtlas = MONGODB_URL.includes(\"mongodb+srv://\");\n\n  const connectionOptions: any = {\n    dbName: \"InstantAI\",\n    bufferCommands: false,\n    // Connection options to handle SSL issues\n    maxPoolSize: 10,\n    serverSelectionTimeoutMS: 10000,\n    socketTimeoutMS: 45000,\n    // Retry options\n    retryWrites: true,\n    w: \"majority\" as any,\n  };\n\n  // Add SSL options based on connection type\n  if (isAtlas) {\n    // MongoDB Atlas specific options\n    Object.assign(connectionOptions, {\n      ssl: true,\n      tls: true,\n      tlsAllowInvalidCertificates: false,\n      tlsAllowInvalidHostnames: false,\n      // Atlas specific SSL options\n      sslCA: undefined,\n      sslCert: undefined,\n      sslKey: undefined,\n      sslPass: undefined,\n    });\n    console.log(\"Using MongoDB Atlas SSL configuration\");\n  } else {\n    // Local MongoDB options\n    Object.assign(connectionOptions, {\n      ssl: false,\n      tls: false,\n    });\n    console.log(\"Using local MongoDB configuration\");\n  }\n\n  console.log(\n    \"Connection options:\",\n    JSON.stringify(connectionOptions, null, 2)\n  );\n\n  cached.promise =\n    cached.promise || mongoose.connect(MONGODB_URL, connectionOptions);\n\n  try {\n    cached.conn = await cached.promise;\n    console.log(\"Database connection established successfully\");\n  } catch (error) {\n    console.error(\"Database connection failed:\", error);\n    // Reset the promise on failure\n    cached.promise = null;\n    throw error;\n  }\n\n  return cached.conn;\n};\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,cAAc,QAAQ,GAAG,CAAC,WAAW;AAO3C,IAAI,SAA6B,4CAAgB,QAAQ;AAEzD,IAAI,CAAC,QAAQ;IACX,SAAS,4CAAgB,QAAQ,GAAG;QAClC,MAAM;QACN,SAAS;IACX;AACF;AAEO,MAAM,cAAc;IACzB,QAAQ,GAAG,CAAC;IACZ,QAAQ,GAAG,CAAC,uBAAuB,CAAC,CAAC;IAErC,+CAA+C;IAC/C,IAAI,aAAa;QACf,MAAM,MAAM;QACZ,MAAM,cAAc,IAAI,OAAO,CAC7B,wCACA;QAEF,QAAQ,GAAG,CAAC,2BAA2B;QAEvC,uDAAuD;QACvD,IACE,IAAI,QAAQ,CAAC,qBACb,CAAC,IAAI,QAAQ,CAAC,eACd,CAAC,IAAI,QAAQ,CAAC,aACd;YACA,QAAQ,GAAG,CACT;QAEJ;IACF,OAAO;QACL,QAAQ,GAAG,CAAC;IACd;IAEA,IAAI,OAAO,IAAI,EAAE;QACf,QAAQ,GAAG,CAAC;QACZ,OAAO,OAAO,IAAI;IACpB;IAEA,IAAI,CAAC,aAAa,MAAM,IAAI,MAAM;IAElC,QAAQ,GAAG,CAAC;IAEZ,6DAA6D;IAC7D,MAAM,UAAU,YAAY,QAAQ,CAAC;IAErC,MAAM,oBAAyB;QAC7B,QAAQ;QACR,gBAAgB;QAChB,0CAA0C;QAC1C,aAAa;QACb,0BAA0B;QAC1B,iBAAiB;QACjB,gBAAgB;QAChB,aAAa;QACb,GAAG;IACL;IAEA,2CAA2C;IAC3C,IAAI,SAAS;QACX,iCAAiC;QACjC,OAAO,MAAM,CAAC,mBAAmB;YAC/B,KAAK;YACL,KAAK;YACL,6BAA6B;YAC7B,0BAA0B;YAC1B,6BAA6B;YAC7B,OAAO;YACP,SAAS;YACT,QAAQ;YACR,SAAS;QACX;QACA,QAAQ,GAAG,CAAC;IACd,OAAO;QACL,wBAAwB;QACxB,OAAO,MAAM,CAAC,mBAAmB;YAC/B,KAAK;YACL,KAAK;QACP;QACA,QAAQ,GAAG,CAAC;IACd;IAEA,QAAQ,GAAG,CACT,uBACA,KAAK,SAAS,CAAC,mBAAmB,MAAM;IAG1C,OAAO,OAAO,GACZ,OAAO,OAAO,IAAI,yGAAA,CAAA,UAAQ,CAAC,OAAO,CAAC,aAAa;IAElD,IAAI;QACF,OAAO,IAAI,GAAG,MAAM,OAAO,OAAO;QAClC,QAAQ,GAAG,CAAC;IACd,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,+BAA+B;QAC7C,+BAA+B;QAC/B,OAAO,OAAO,GAAG;QACjB,MAAM;IACR;IAEA,OAAO,OAAO,IAAI;AACpB","debugId":null}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///Users/ryanbakker/Dev/finova/database/models/liability.model.ts"],"sourcesContent":["import mongoose, { Schema, Document } from 'mongoose';\n\nexport interface ILiability extends Document {\n    userId: string;\n    name: string;\n    category: string;\n    amount: number;\n    currency: string;\n    institution?: string;\n    accountNumber?: string;\n    dueDate?: Date;\n    interestRate?: number;\n    monthlyPayment?: number;\n    remainingBalance?: number;\n    originalAmount?: number;\n    notes?: string;\n    isActive: boolean;\n    createdAt: Date;\n    updatedAt: Date;\n}\n\nconst liabilitySchema = new Schema<ILiability>({\n    userId: {\n        type: String,\n        required: [true, 'User ID is required'],\n        index: true,\n        trim: true\n    },\n    name: {\n        type: String,\n        required: [true, 'Liability name is required'],\n        trim: true,\n        minlength: [1, 'Liability name must be at least 1 character long'],\n        maxlength: [100, 'Liability name cannot exceed 100 characters']\n    },\n    category: {\n        type: String,\n        required: [true, 'Category is required'],\n        trim: true,\n        minlength: [1, 'Category must be at least 1 character long'],\n        maxlength: [50, 'Category cannot exceed 50 characters']\n    },\n    amount: {\n        type: Number,\n        required: [true, 'Amount is required'],\n        min: [0, 'Amount must be non-negative'],\n        max: [999999999, 'Amount cannot exceed 999,999,999']\n    },\n    currency: {\n        type: String,\n        required: [true, 'Currency is required'],\n        default: 'USD',\n        trim: true,\n        uppercase: true,\n        minlength: [3, 'Currency must be at least 3 characters'],\n        maxlength: [3, 'Currency must be exactly 3 characters']\n    },\n    institution: {\n        type: String,\n        required: false,\n        trim: true,\n        maxlength: [100, 'Institution name cannot exceed 100 characters']\n    },\n    accountNumber: {\n        type: String,\n        required: false,\n        trim: true,\n        maxlength: [50, 'Account number cannot exceed 50 characters']\n    },\n    dueDate: {\n        type: Date,\n        required: false,\n        validate: {\n            validator: function(value: Date) {\n                if (!value) return true; // Optional field\n                const now = new Date();\n                const maxDate = new Date(now.getFullYear() + 30, now.getMonth(), now.getDate()); // 30 years in future\n                return value >= now;\n            },\n            message: 'Due date cannot be in the past'\n        }\n    },\n    interestRate: {\n        type: Number,\n        required: false,\n        min: [0, 'Interest rate must be non-negative'],\n        max: [100, 'Interest rate cannot exceed 100%'],\n        validate: {\n            validator: function(value: number) {\n                if (value === undefined || value === null) return true; // Optional field\n                return value >= 0 && value <= 100;\n            },\n            message: 'Interest rate must be between 0% and 100%'\n        }\n    },\n    monthlyPayment: {\n        type: Number,\n        required: false,\n        min: [0, 'Monthly payment must be non-negative'],\n        max: [999999999, 'Monthly payment cannot exceed 999,999,999'],\n        validate: {\n            validator: function(value: number) {\n                if (value === undefined || value === null) return true; // Optional field\n                return value >= 0;\n            },\n            message: 'Monthly payment must be non-negative'\n        }\n    },\n    remainingBalance: {\n        type: Number,\n        required: false,\n        min: [0, 'Remaining balance must be non-negative'],\n        max: [999999999, 'Remaining balance cannot exceed 999,999,999'],\n        validate: {\n            validator: function(value: number) {\n                if (value === undefined || value === null) return true; // Optional field\n                return value >= 0;\n            },\n            message: 'Remaining balance must be non-negative'\n        }\n    },\n    originalAmount: {\n        type: Number,\n        required: false,\n        min: [0, 'Original amount must be non-negative'],\n        max: [999999999, 'Original amount cannot exceed 999,999,999'],\n        validate: {\n            validator: function(value: number) {\n                if (value === undefined || value === null) return true; // Optional field\n                return value >= 0;\n            },\n            message: 'Original amount must be non-negative'\n        }\n    },\n    notes: {\n        type: String,\n        required: false,\n        trim: true,\n        maxlength: [500, 'Notes cannot exceed 500 characters']\n    },\n    isActive: {\n        type: Boolean,\n        required: [true, 'Active status is required'],\n        default: true\n    }\n}, {\n    timestamps: true\n});\n\n// Compound index for efficient queries\nliabilitySchema.index({ userId: 1, category: 1 });\nliabilitySchema.index({ userId: 1, isActive: 1 });\nliabilitySchema.index({ userId: 1, dueDate: 1 });\n\n// Pre-save middleware to set default values\nliabilitySchema.pre('save', function(next) {\n    // Set remaining balance to amount if not provided\n    if (this.remainingBalance === undefined || this.remainingBalance === null) {\n        this.remainingBalance = this.amount;\n    }\n    \n    // Set original amount to amount if not provided\n    if (this.originalAmount === undefined || this.originalAmount === null) {\n        this.originalAmount = this.amount;\n    }\n    \n    next();\n});\n\n// Virtual for calculating total interest paid\nliabilitySchema.virtual('totalInterestPaid').get(function() {\n    if (this.originalAmount && this.remainingBalance) {\n        return Math.max(0, this.originalAmount - this.remainingBalance);\n    }\n    return 0;\n});\n\n// Virtual for calculating progress percentage\nliabilitySchema.virtual('progressPercentage').get(function() {\n    if (this.originalAmount && this.remainingBalance) {\n        const paid = this.originalAmount - this.remainingBalance;\n        return Math.min(100, Math.max(0, (paid / this.originalAmount) * 100));\n    }\n    return 0;\n});\n\n// Ensure virtual fields are serialized\nliabilitySchema.set('toJSON', { virtuals: true });\nliabilitySchema.set('toObject', { virtuals: true });\n\nconst Liability = mongoose.models.Liability || mongoose.model<ILiability>('Liability', liabilitySchema);\n\nexport default Liability;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 360, "column": 0}, "map": {"version":3,"sources":["file:///Users/ryanbakker/Dev/finova/lib/actions/liability.actions.ts"],"sourcesContent":["\"use server\";\n\nimport { revalidatePath } from \"next/cache\";\nimport { handleError } from \"../utils\";\nimport { connectToDB } from \"@/database/db\";\nimport Liability from \"@/database/models/liability.model\";\nimport { auth } from \"@clerk/nextjs/server\";\n\ndeclare type CreateLiabilityParams = {\n  name: string;\n  category: string;\n  amount: number;\n  currency: string;\n  institution?: string;\n  accountNumber?: string;\n  dueDate?: string;\n  interestRate?: number;\n  monthlyPayment?: number;\n  remainingBalance?: number;\n  originalAmount?: number;\n  notes?: string;\n  isActive?: boolean;\n};\n\ndeclare type UpdateLiabilityParams = {\n  name?: string;\n  category?: string;\n  amount?: number;\n  currency?: string;\n  institution?: string;\n  accountNumber?: string;\n  dueDate?: string;\n  interestRate?: number;\n  monthlyPayment?: number;\n  remainingBalance?: number;\n  originalAmount?: number;\n  notes?: string;\n  isActive?: boolean;\n};\n\n// Helper function to get authenticated user ID\nasync function getAuthenticatedUserId(): Promise<string> {\n  const { userId } = await auth();\n  if (!userId) {\n    throw new Error(\"Unauthorized: User not authenticated\");\n  }\n  return userId;\n}\n\nexport async function createLiability(liability: CreateLiabilityParams) {\n  try {\n    const userId = await getAuthenticatedUserId();\n    await connectToDB();\n\n    // Create new liability with user ID\n    const newLiability = await Liability.create({\n      ...liability,\n      userId,\n      // Convert string dates to Date objects if provided\n      dueDate: liability.dueDate ? new Date(liability.dueDate) : undefined,\n    });\n\n    revalidatePath(\"/liabilities\");\n    return JSON.parse(JSON.stringify(newLiability));\n  } catch (error) {\n    handleError(error);\n    throw error;\n  }\n}\n\nexport async function getLiabilitiesByUserId() {\n  try {\n    const userId = await getAuthenticatedUserId();\n    await connectToDB();\n\n    const liabilities = await Liability.find({ userId })\n      .sort({ createdAt: -1 })\n      .lean();\n\n    return JSON.parse(JSON.stringify(liabilities));\n  } catch (error) {\n    handleError(error);\n    throw error;\n  }\n}\n\nexport async function getLiabilityById(liabilityId: string) {\n  try {\n    const userId = await getAuthenticatedUserId();\n    await connectToDB();\n\n    // Ensure user can only access their own liability\n    const liability = await Liability.findOne({\n      _id: liabilityId,\n      userId\n    }).lean();\n\n    if (!liability) {\n      throw new Error(\"Liability not found or access denied\");\n    }\n\n    return JSON.parse(JSON.stringify(liability));\n  } catch (error) {\n    handleError(error);\n    throw error;\n  }\n}\n\nexport async function updateLiability(liabilityId: string, updates: UpdateLiabilityParams) {\n  try {\n    const userId = await getAuthenticatedUserId();\n    await connectToDB();\n\n    // Ensure user can only update their own liability\n    const existingLiability = await Liability.findOne({\n      _id: liabilityId,\n      userId\n    });\n\n    if (!existingLiability) {\n      throw new Error(\"Liability not found or access denied\");\n    }\n\n    // Convert string dates to Date objects if provided\n    const updateData: Record<string, unknown> = { ...updates };\n    if (updates.dueDate) {\n      updateData.dueDate = new Date(updates.dueDate);\n    }\n\n    const updatedLiability = await Liability.findByIdAndUpdate(\n      liabilityId,\n      updateData,\n      { new: true, runValidators: true }\n    );\n\n    if (!updatedLiability) {\n      throw new Error(\"Failed to update liability\");\n    }\n\n    revalidatePath(\"/liabilities\");\n    return JSON.parse(JSON.stringify(updatedLiability));\n  } catch (error) {\n    handleError(error);\n    throw error;\n  }\n}\n\nexport async function deleteLiability(liabilityId: string) {\n  try {\n    const userId = await getAuthenticatedUserId();\n    await connectToDB();\n\n    // Ensure user can only delete their own liability\n    const existingLiability = await Liability.findOne({\n      _id: liabilityId,\n      userId\n    });\n\n    if (!existingLiability) {\n      throw new Error(\"Liability not found or access denied\");\n    }\n\n    const deletedLiability = await Liability.findByIdAndDelete(liabilityId);\n\n    if (!deletedLiability) {\n      throw new Error(\"Failed to delete liability\");\n    }\n\n    revalidatePath(\"/liabilities\");\n    return JSON.parse(JSON.stringify(deletedLiability));\n  } catch (error) {\n    handleError(error);\n    throw error;\n  }\n}\n\nexport async function getLiabilityStats() {\n  try {\n    const userId = await getAuthenticatedUserId();\n    await connectToDB();\n\n    const stats = await Liability.aggregate([\n      { $match: { userId, isActive: true } },\n      {\n        $group: {\n          _id: null,\n          totalLiabilities: { $sum: 1 },\n          totalAmount: { $sum: \"$amount\" },\n          totalRemainingBalance: { $sum: \"$remainingBalance\" },\n          totalMonthlyPayments: { $sum: { $ifNull: [\"$monthlyPayment\", 0] } },\n          averageInterestRate: { $avg: \"$interestRate\" }\n        }\n      }\n    ]);\n\n    const categoryBreakdown = await Liability.aggregate([\n      { $match: { userId, isActive: true } },\n      {\n        $group: {\n          _id: \"$category\",\n          count: { $sum: 1 },\n          totalAmount: { $sum: \"$amount\" },\n          totalRemainingBalance: { $sum: \"$remainingBalance\" }\n        }\n      },\n      { $sort: { totalAmount: -1 } }\n    ]);\n\n    return {\n      summary: stats[0] || {\n        totalLiabilities: 0,\n        totalAmount: 0,\n        totalRemainingBalance: 0,\n        totalMonthlyPayments: 0,\n        averageInterestRate: 0\n      },\n      categoryBreakdown\n    };\n  } catch (error) {\n    handleError(error);\n    throw error;\n  }\n}\n\nexport async function searchLiabilities(query: string, filters?: {\n  category?: string;\n  status?: string;\n  minAmount?: number;\n  maxAmount?: number;\n}) {\n  try {\n    const userId = await getAuthenticatedUserId();\n    await connectToDB();\n\n    const searchQuery: Record<string, unknown> = { userId };\n\n    // Text search\n    if (query) {\n      searchQuery.$or = [\n        { name: { $regex: query, $options: 'i' } },\n        { institution: { $regex: query, $options: 'i' } },\n        { notes: { $regex: query, $options: 'i' } }\n      ];\n    }\n\n    // Apply filters\n    if (filters?.category) {\n      searchQuery.category = filters.category;\n    }\n\n    if (filters?.status === 'active') {\n      searchQuery.isActive = true;\n    } else if (filters?.status === 'inactive') {\n      searchQuery.isActive = false;\n    }\n\n    if (filters?.minAmount !== undefined || filters?.maxAmount !== undefined) {\n      (searchQuery.amount as Record<string, number>) = {};\n      if (filters.minAmount !== undefined) {\n        (searchQuery.amount as Record<string, number>).$gte = filters.minAmount;\n      }\n      if (filters.maxAmount !== undefined) {\n        (searchQuery.amount as Record<string, number>).$lte = filters.maxAmount;\n      }\n    }\n\n    const liabilities = await Liability.find(searchQuery)\n      .sort({ createdAt: -1 })\n      .lean();\n\n    return JSON.parse(JSON.stringify(liabilities));\n  } catch (error) {\n    handleError(error);\n    throw error;\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 670, "column": 0}, "map": {"version":3,"sources":["file:///Users/ryanbakker/Dev/finova/app/%28dashboard%29/liabilities/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/app/(dashboard)/liabilities/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/app/(dashboard)/liabilities/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,4WAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAwS,GACrU,sEACA","debugId":null}},
    {"offset": {"line": 682, "column": 0}, "map": {"version":3,"sources":["file:///Users/ryanbakker/Dev/finova/app/%28dashboard%29/liabilities/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/app/(dashboard)/liabilities/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/app/(dashboard)/liabilities/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,4WAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoR,GACjT,kDACA","debugId":null}},
    {"offset": {"line": 694, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}